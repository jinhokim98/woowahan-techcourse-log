# 자바스크립트 언어의 특성

## 변수
  + js는 개발자의 직접 메모리 제어를 허용하지 않는다. C는 가능하지만
  + 식별자는 값이 아니라 메모리 주소를 기억하고 있다.
  
  + 변수 선언의 실행시점과 변수 호이스팅
    - 변수 호이스팅: 소스코드의 평가 과정에서 모든 선언문을 맨 위로 올린다.
    - 그러므로 호출이 선언보다 먼저 있어도 참조에러가 발생하지 않는다.

  + 값의 할당
    - 선언은 호이스팅되지만 할당은 런타임 시점에 순서대로 실행된다.
    - undefined가 먼저 할당되고 값이 할당될 때, 값이 변경 x 다른 곳에 재할당 (주의)

  + 가비지 콜렉터
    - 어떤 식별자도 참조하지 않는 메모리 공간을 해제해간다. 언제 실행될지는 모름
  
  + 네이밍 컨벤션
    - 변수나 함수는 카멜케이스
    - 생성자 함수 클래스의 이름은 파스칼케이스

+ 데이터 타입
  - 숫자 타입 -> 정수만을 위한 타입이 없고, 모든 수를 실수로 처리
    - 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있다.
  - undefined
    - 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값
    - 개발자가 의도로 undefined를 초기화하는 것은 좋지 않다 -> 혼란을 줄 수 있으므로
  - null
    - 빈 값
    - 개발자가 의도로 빈 값을 할당하고 싶을 때 사용
  
+ 동적 타이핑
  - 변수는 할당에 의해 타입이 결정된다. 재할당을 통해 타입은 언제든지 변할 수 있다.

+ 암묵적 타입변환
  - 문자열 타입으로 변환
    - ''을 붙이면 문자열로 변환 -> toString()보다 ''을 더하는 것을 추천
    - [10, 20] + '' -> "10,20"
    - true + '' -> "true"
  - 숫자 타입으로 변환
    - + '0' -> 0

+ 단축평가
  - 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때
    ```js
    var elem = null;
    var value = elem && elem.value;
    ```

    위와 같이 해주면 vlaue의 값이 null로 되어, 에러를 발생시키지 않는다.

  - 옵셔널 체이닝 연산자
    ```js
    var elem = null;
    var value = elem?.value;
    ```
  
  - null 병합 연산자
    ```js
    var elem = null ?? 'defalut';
    ```

  
## 객체 리터럴
  - 프로퍼티: 객체의 상태를 나타내는 값
  - 메서드: 프로퍼티를 참조하고 조작할 수 있는 동작 (메서드 !== 함수)
  
  - 객체를 생성하는 방법
    + 객체 리터럴
    + Object 생성자 함수
    + 생성자 함수
    + Object.create 메서드
    + 클래스
  
  - 프로퍼티
    - 키에 문자열이나 심벌 값 외의 값을 사용하면 암묵적 타입 변환으로 문자열이 된다.
  
  - 메서드
    - 객체에 묶여있는 함수
  
  - 계산된 프로퍼티 이름
  ```js
  const prefix = 'hello';
  let i = 0;

  const obj = {};

  obj[prefix + '-' + ++i] = i;
  obj[prefix + '-' + ++i] = i;
  obj[prefix + '-' + ++i] = i;
  ```
  -> {hello-1: 1, hello-2: 2, hello-3: 3}


## 원시 값과 객체의 비교
  - 원시 타입의 값: 변경 불가능한 값 -> 실제 값
  - 객체를 변수에 할당: 참조 값이 저장
  - 문자열을 생성하고 특정 인덱스를 바꾼다고해도 변하지 않는다 -> 데이터의 불변성


## 함수
  - 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출된다.
  - 인수 -> 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 저장된다.
  - 함수 외부에서 함수 내부로 전달한 객체를 내부에서 변경하면 외부의 상태가 변하는 부수 효과 발생 (좋지 않음)
  
  - 순수 함수
    + 외부 상태를 변경하지 않고, 외부 상태에 의존하지도 않는 함수

  - 콜백 함수
    + 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
  
  - 고차 함수
    + 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
  
  13장부터 보기